% -*- coding: utf-8; ispell-dictionary: "french"; -*-

%------------------------------------
% Chapter 3 - Schémas de traduction
%------------------------------------


Dans les deux parties précédentes, nous avons posé les différents
éléments de Scade et de la méthode B dont nous avions besoin pour
établir la traduction. Cette partie définit les schémas de traduction
utilisés pour réaliser le traducteur. \\

\section{Machine Abstraite}

La machine abstraite est engendrée à partir du contrat du composant. Ce sont
donc les conditions posées par les instructions \texttt{assume} et
\texttt{guarantee} qui nous intéressent. Le nom de l'opération sera le même que le
nom de la définition Scade. 

\subsection{Traduction de la déclaration du noeud}
La déclaration d'un noeud Scade comporte le nom du composant, ses
entrées/sorties, et le type de ses entrées/sorties. En B, on reprend ces
informations sur le nom du noeud et le nom des entrées et sorties pour déclarer une
opération. Ainsi la déclaration Scade: 
\begin{alltt}
node mon\_noeud (in_1: type\_in_1, ..., in_n: type\_in_n) 
                returns (out_1: type\_out_1, ..., out_m: type\_out_m);
\end{alltt}
devient l'opération B:
\begin{alltt}
in_1, ..., in_n \(\leftarrow\) mon\_noeud(out_1, ..., out_m) =
\end{alltt}

\noindent
En reprenant le noeud \texttt{bound}, la traduction donne:\\
\texttt{vv $\leftarrow$ bound(zz, b\_inf, b\_sup) =}\\
On peut noter que le nom de la variable de sortie a été
modifié par rapport à la version de Scade. Dans B, les noms de variables n'ayant qu'une lettre sont
réservés, donc on effectue un rennomage sur l'ensemble des variables
du programmes: les lettres simples sont doublées, et si le nouveau nom
est déjà utilisé par une autre variable, on redouble le nom jusqu'à ce
qu'il n'y ait aucun conflit dans les noms de variables.

\paragraph{Traduction des types de base}
Les informations de type sur les entrées et sorties sont reprises pour les
préconditions et postconditions.
La traduction des types de base est directe:
\begin{itemize}
\item int est traduit par INT
\item real est traduit par REAL
\item bool est traduit par BOOL
\end{itemize}


\subsection{Traduction des conditions}

La machine abstraite de B forme une spécification de la machine implanté,
l'opération est ainsi ordinairement consitué d'une substitution précondition
PRE P THEN S END. P étant le prédicat correspondant aux conditions des
\texttt{assumes} et aux informations de typage sur les entrées, tandis que S est
la substitution qui reprend les conditions sur les \texttt{guarantees} et les informations de typage
sur les sorties. 

\paragraph{Traduction des préconditions}
Les instructions \texttt{assumes} sont des formules logiques, généralement des
restrictions sur des intervalles. Les opérateurs logiques utilisés sont les
mêmes pour Scade que pour le langage B, la traduction est donc directe. Les
conditions sur les différentes entrées sont combinées par un opérateur ET
logique (\&). La condition est précédée par le type de la variable, reprit
depuis la déclaration Scade. 
Dans le cas où une variable d'entrée ou de sortie n'est pas conditionnée, comme
c'est souvent le cas pour les variables booléennes, alors on indique seulement
le type de la variable.

\noindent
En reprenant l'exemple bound, les prédicats générés pour les
préconditions sont:\\

\noindent
\texttt{zz $\in$ INT \& zz <= 2000 \& zz >= -2000 \& \\
b\_sup $\in$ INT \& b\_sup <= 2000 \& b\_sup >= -2000 \& \\
b\_inf $\in$ INT \& b\_inf <= 2000 \& b\_inf >= -2000 \\
}


\paragraph{Traduction des postconditions}
Les instructions \texttt{guarantees} sont également des formules
logiques. Cependant, on utilise des substitution \emph{Devient Element De} pour
les post-conditions, que l'on combine avec une définition d'ensemble
en compréhension. Les variables en sortie auront une valeur respectant
la postcondition qui va être utilisée pour définir l'ensemble en
compréhension. 
Les conditions sont regroupée dans une substitution parallèle,
elles sont séparées par un ||. 
Les substitutions seront de la forme:
\begin{alltt}
out \(\in\): \{ ii | ii \(\in\) type_out & C \}
\end{alltt}
avec \texttt{out} la variable de sortie, \texttt{type\_out} son type, et \texttt{C} la
postcondition associée. Un rennomage est effectué sur la condition \texttt{C},
car elle porte alors sur la variable \texttt{ii}. Avant d'effectuer le rennomage, on
vérifie que la nouvelle variable n'existe pas déjà dans l'environnement.\\
En reprenant l'exemple de \texttt{bound} on obtient pour v:\\
\texttt{vv $\in$: \{ ii | ii $\in$ INT \& ii <= 200 \& ii >= -2000 \}}


\subsection{Le cas des tableaux}
La traduction des conditions pour les tableaux est moins directe, car il n'y a
pas de type primitif pour les tableaux en B. On utilise des fonctions à la
place. 

\paragraph{Traduction des types}
Les tableaux peuvent être multi-dimensionnels, mais ne peuvent contenir qu'un
seul type de donnée. On peut voir les tableaux comme des fonctions prennant
comme argument l'indice de la donnée stockée, et retournant la valeur de cette
donnée. Les tableaux sont indexés par des entiers, sélectionnés dans les
intervalles allant de 0 à la taille du tableau - 1.
Par exemple, pour une matrice \emph{Mat} de n lignes et m colonnes, les valeurs
des données sont accessibles ainsi: $Mat(p, q)$, avec $0 \leq p \leq n-1$ et $0 \leq q
\leq m-1$.
Ainsi, le schéma correspondant à la traduction de la déclaration d'un tableau
est:
\begin{alltt}
nom\_tableau : type\_tableau \^ dim_1 \^ ... \^ dim_n
\end{alltt}
devient en B:
\begin{alltt}
nom\_tableau : (0..dim_1-1, ..., 0..dim_n-1) \(\rightarrow\) type\_tableau 
\end{alltt}
Dans la traduction B, la notation \texttt{0..dim$_1$-1} correspond à un
intervalle allant de \texttt{0} à la valeur de \texttt{dim$_1$-1}

\paragraph{Traduction des formules logiques}
Les conditions sur les tableaux en B ont été évoquées dans la section sur les
quantificateurs en B. Les conditions portent sur l'ensemble des données
contenues dans le tableau. La condition est alors de la forme: pour toute valeur
\texttt{jj} correspondant à un index du tableau, la donnée référencée par cet index
respecte la condition donnée. Ainsi, une formule logique \texttt{f\_l} portant sur un
tableau de n dimensions correspond à la formule B: 
\begin{alltt}
\(\forall \)jj. (jj : (1..dim_1, ..., 1..dim_n) \(\rightarrow\) f\_l)
\end{alltt}

Prenons par exemple un tableau Tab de taille 2 comprenant des entiers. La condition
associée à Tab est que ses éléments doivent être compris entre 0 et 10 exclus.\\
Le type du tableau sera alors: \\
\texttt{Tab : (0 .. 1) $\rightarrow$ INT }\\
Et la formule associée au tableau sera: \\
\texttt{$\forall$jj. (jj $\in$ (0 .. 1) => 0 < Tab(jj) \& Tab(jj) < 10)}

\subsection{schéma général}

Le schéma de traduction d'un composant Scade foo en une machine abstraite B est
le suivant:

\setlength{\columnseprule}{0.05cm}
\begin{multicols}{2}
\begin{alltt}
\textbf{node} foo 
  (in\(\sb{1}\): in\(\sb{1}\)\_type, ..., in\(\sb{p}\): in\(\sb{p}\)\_type) 
  \textbf{returns}
  (out\(\sb{1}\): out\(\sb{1}\)\_type, ..., out\(\sb{q}\): out\(\sb{q}\)\_type);
\textbf{var}

  ...

\textbf{let}
  assume A\(\sb{1}\) : pred\_in\(\sb{1}\);
  ...
  assume A\(\sb{p}\) : pred\_in\(\sb{p}\);

  \( liste d'equations \)

  guarantee G\(\sb{1}\) : pred\_out\(\sb{1}\);
  ...
  guarantee G\(\sb{q}\) : pred\_out\(\sb{q}\);
\textbf{tel;}
\end{alltt}
\columnbreak

\begin{alltt}
\textbf{MACHINE} Foo

\textbf{OPERATION}

out\(\sb{1}\), ..., out\(\sb{q}\) \(\leftarrow\) foo(in\(\sb{1}\), ..., in\(\sb{p}\)) =
  \textbf{PRE}
    in\(\sb{1}\) \(\in\) in\(\sb{1}\)\_type & pred\_in\(\sb{1}\) &
    ... &
    in\(\sb{p}\) \(\in\) in\(\sb{p}\)\_type & pred\_in\(\sb{p}\) &
  \textbf{THEN}
    out\(\sb{1}\) \(\in\): \{ iii | iii \(\in\) out\(\sb{1}\)\_type & pred\_out\(\sb{1}\)\}
    ...
    out\(\sb{q}\) \(\in\): \{ iii | iii \(\in\) out\(\sb{q}\)\_type & pred\_out\(\sb{q}\)\}
  \textbf{END}
\textbf{END}
\end{alltt}
\end{multicols}

\noindent
Les formules booléennes sont notées \texttt{pred\_nom} où nom
correspond au nom de la variable concernée par cette formule, qui a
la même syntaxe en Scade et en B. De plus, les variables locales ne sont pas
considérées dans la machine abstraite.

\section{Implantation}

\subsection{Traduction des variables locales}
Les variables locales correspondent aux fils de Scade. Elles sont générées
automatiquement et leur identifiant est de la forme: \texttt{\_L}X, où X est un
numéro. Dans le langage B, les identifiants ne peuvent commencer par
un \texttt{"\_"}. Donc un rennomage est effectué sur l'ensemble des variables
locales pour supprimer le \texttt{"\_"}, en vérifiant que le nouvel identifiant
n'est pas déjà présent dans l'environnement. Si le nouvel identifiant \texttt{L}X est déjà
utilisé, alors on ajoute une lettre à l'identifiant jusqu'à ce que ce dernier ne
soit pas déjà présent dans l'environnement.

\subsection{Traduction des équations}

Les équations sont traduites différemment selon la "famille" d'expression qu'elles
contiennent.  
Concernant la partie droite, il y a 4 familles d'expressions de Scade à traduire en B:
\begin{itemize}
\item Les expressions à manipulant les variables, constantes et opérateurs de
  base (arithmétiques, relationnels, booléens,...).
\item Les appels de noeuds, sous réserve que le noeud appelé a déjà été
  traduit. 
\item L'alternative.
\item Le registre.
\end{itemize}

\paragraph{Opérateurs de base}
Les opérateurs de base sont traduits par une substitution \emph{Devient Egal}, on
effectue une simple affectation. Les opérateurs de base de Scade sont identiques
à ceux du langage B. Le membre gauche de l'équation correspond à une unique
variable, les opérations étant atomiques dans Scade. \\

\texttt{$a = op_{base}(b_1,...,b_n)$ $\xrightarrow{traduction ~
equations}$ $a:=op_{base}(b_1,...,b_n)$. }

Si l'opérateur est un opérateur de prédicat tel que les opérateurs booléens, ou
les opérateurs de comparaison, alors l'opération sera précédée par
l'opérateur \texttt{bool}, car la partie droite des substitutions \emph{Devient
Egal} ne peuvent contenir que des expressions, et l'opérateur \texttt{bool}
permet de transformer un prédicat en expression.


\paragraph{Appel de noeud}
Un appel de noeud est traduit par une substitution \emph{Appel d'Opération}. Le
membre gauche de l'équation contient autant de variables qu'il y a de sorties
pour le noeud appelé. Le noeud appelé doit avoir été traduit auparavant, et la
machine B correspondante doit être présente dans la clause \texttt{IMPORT}.\\

\texttt{$(a_1, ... a_n) = op_{appel}(b_1, ..., b_m)$
$\xrightarrow{traduction ~ equations}$ $(a_1, ... a_n) \leftarrow
op_{appel}(b_1,..., b_n)$} 

\paragraph{Alternative}
On traduit l'alternative par la substitution \emph{Condition}. On utilise
également la substitution \emph{Devient Egal} pour chaque branche de
l'alternative.
La condition doit correspondre à un prédicat, or si c'est une simple variable,
elle sera considérée comme une expression. Pour la transformer en prédicat, la
condition B sera une égalité entre la condition Scade et la valeur
booléenne \texttt{TRUE}.

\noindent
\begin{small}
\texttt{$ a=if~cond~then~b1~else~b2\xrightarrow{traduction~equations}IF~cond=TRUE~THEN~a:=b1~ELSE~a:=b2~END$}
\end{small}
\subsection*{Registres}

Le registre est également traduit en substitution \emph{Devient Egal}, cependant
les substitutions correspondantes doivent être placées après les autres. Ces
équations correspondent à la mise à jour de l'état d'une variable, la mise à
jour est donc faite à la fin de l'opération. La valeur initiale du registre doit
être indiquée dans la clause \texttt{INITIALISATION} de la machine et la variable d'état
correspondant au registre doit être déclarée dans \texttt{CONCRETE\_VARIABLE}. De
plus il faut indiquer dans la clause \texttt{INVARIANT} les contraintes de typage
de la variable d'état. \\

\texttt{$a = fby(ini, delai, b) \xrightarrow{traduction ~ equations} a := b$ }\\

Dans Scade, les équations correspondant aux registres sont initialisées à une
certaine valeur, puis ils prennent la valeur d'une autre variable après un
certain délai, supérieur à 1.
Avec B, on a un langage impératif sans notion de temps, mais dont les machines
peuvent avoir un état grâce à des variables d'état déclarées dans la
clause \texttt{CONCRETE\_VARIABLES}. Pour traduire un registre avec un délai égal
à 1, il faut donc une variable d'état qui sera initialisée avec la valeur
d'initialisation déclarée dans l'opérateur \texttt{fby}, et il faudra mettre à
jour ce registre à la fin de l'opération.

L'initialisation doit se faire dans la clause \texttt{INITIALISATION}, et
l'information de type du registre doit être indiquée dans la
clause \texttt{INVARIANT}. De plus, si le registre porte sur une variable d'entrée ou de sortie,
on peut alors récupérer la condition (si elle existe) sur l'entrée ou la sortie
en question pour compléter le prédicat de la clause \texttt{INVARIANT}. 

Ainsi, soit un registre reg de type t avec un délai de 1, ayant l'équation suivante :\\
\texttt{reg = fby(ini, 1, a)} \\
avec a une variable d'entrée ou de sortie du composant, possédant une
précondition ou postcondition P, et ini une valeur d'initialisation de
reg. \\
Cependant, la condition P porte sur une variable d'entrée ou de sortie que l'on
connait, et on veux qu'elle porte sur le registre, il faut donc effectuer un
renommage de la condition P en remplaçant les occurence du nom de la variable
concernée par le nom du registre. On obtient une condition P$_{reg}$. \\
Pour résumer, on obtiendra dans l'implantation:

\begin{alltt}
\textbf{IMPLEMENTATION} ...
...
\textbf{CONCRETE\_VARIABLES} ..., reg
\textbf{INVARIANT}
  ...& reg : t & P\(\sb{reg}\)
\textbf{INITIALISATION}
  ... ; reg := ini

\textbf{OPERATION}
... =
\textbf{VAR} ... \textbf{IN}
  ...;
  reg := a
\textbf{END}
\end{alltt}

Dans le cas ou on fixe le délai de l'opérateur \texttt{fby} à 2 ou plus, il faut
introduire de nouvelle variables d'état intermédiaires. On ne peut simuler qu'un
registre ayant un délai égal à 1, donc pour tout registre ayant un délai
supérieur, il faudra introduire (délai - 1) nouvelles variables. Toute les
variables intermédiaires auront la même initialisation et le même invariant que
la variable d'état "principale". A la fin de l'opération, elle devront cependant
être ordonnée correctement, la variable principale doit être affectée en dernière.\\
Prenons par exemple l'équation suivante avec un délai fixé à 3:
\texttt{reg = fby(ini, 3, a)}\\
La machine générée doit être:

\begin{alltt}
\textbf{IMPLEMENTATION} ...
...
\textbf{CONCRETE\_VARIABLES} ..., reg, reg\_i1, reg\_i2
\textbf{INVARIANT}
  ...& reg : t & P\(\sb{reg}\) & 
  reg\_i1 : t & P\(\sb{reg\_i1}\) & 
  reg\_i2 : t & P\(\sb{reg\_i2}\) 
\textbf{INITIALISATION}
  ... ; reg := ini; 
  reg\_i1 := ini; 
  reg\_i2 := ini
\textbf{OPERATION}
... =
\textbf{VAR} ... \textbf{IN}
  ...;
  reg\_i1 := a;
  reg\_i2 := reg\_i1;
  reg := reg\_i2
\textbf{END}
\end{alltt}


\section*{Séquencement des équations}

Dans Scade, l'ordre des équations n'a pas d'importance, une analyse de causalité
est effectuée lors de la validation du noeud. Comme toutes les équations sont
résolues au même instant dans un noeud, cette analyse vérifie qu'un flot
ne dépend jamais de lui même au même instant. Par exemple, on ne peut accepter
une équation du type: \texttt{X = not X}, car au même instant la variable X est
vraie et fausse.  Ainsi, une variable ne peut être
dans la partie droite et gauche d'un équation, sauf si la partie droite est
composée d'un opérateur \texttt{fby}. Dans ce cas, le flot retourné par
l'opérateur correspond à celui d'un instant précédent, donc il n'y a pas de
dépendance directe et l'équation est valide. \\

Cependant, en B les substitutions doivent s'exécuter en séquence. Il faut donc
effectuer un séquencement des équations avant de les traduire en substitutions.
Les équations correspondants aux registres sont
automatiquements placées à la fin, car elles mettent à jour l'état de la machine
après son exécution. Il faut donc effectuer un tri topologique des 3 autres
types d'équations.\\
On utilise alors une fonction de tri prenant en entrées :
\begin{itemize}
\item la liste des équations du programme (sans les équations de registre)
\item un liste de variables comprenant les variables d'entrée du programme et
les registres 
\end{itemize}
La fonction retourne une liste d'équations triées selon l'ordre
topologique.
\newpage
\begin{alltt}
Fonction Tri (eqs: liste d'equations, vars: liste de variables)

eq\_non\_triees : liste d'equations
eq\_admis : liste d'equations
v\_admis : liste de variables 
eq : equation

BEGIN
 eq\_non\_triees <- eqs;
 v\_admis <- vars;
 TANT QUE (eq\_non\_triees \(\neq \emptyset \)) 
    eq <- tete(eq\_non\_triees);
    SI vars\_droite(eq) \(\subset\) v\_admis ALORS
       ajout\_fin(eq\_admis, eq);
       ajout\_fin(v\_admis, vars\_gauche(eq))
    SINON
       ajout\_fin(eq\_non\_triees, eq)
    FIN SI
 FIN TANT QUE
 RETOURNE eq\_admis;
END

\end{alltt}

On utilise 4 procédures externes nécessaires à cet algorithme:
\begin{itemize}
\item \texttt{tete(l)} : retourne le premier élément de la liste \texttt{l} et supprime l'élément
  en question de \texttt{l}
\item \texttt{ajout\_fin(l,e)} : ajoute \texttt{e} à la fin de la liste \texttt{l}
\item \texttt{vars\_droite(e)} : liste des variables contenues dans la partie droite de
  l'équation \texttt{e}
\item \texttt{vars\_gauche(e)} : liste des variables contenues dans la partie gauche de
  l'équation \texttt{e}
\end{itemize}
Pour commencer, les variables d'entrées sont considérées comme admises. Les
premières équations sont celles dont la partie droite ne dépend que des
variables admises. La partie gauche des premières équations est ajoutée à la
liste des variables admises, et on ajoute les équations dont la partie droite
dépend du nouvel ensemble de variables admises. La fonction retourne la liste d'
équations triée.


\subsection{Gestion des clauses SEES et IMPORTS}
Pour inclure des opérations ou des constantes définies dans des machines
externes, il faut les ajouter respectivement dans les clauses \texttt{IMPORTS} et \texttt{SEES} de
la machine courante. Cependant, il n'y a pas de processus automatique pour
ajouter les machines nécessaires dans ces clauses. Il faut donc les ajouter
manuellement une fois la traduction réalisée.


\subsection{Schéma général}

Le nom de la machine reprend le nom de la
définition Scade, cependant le nom de l'opération doit être différent du nom de
la machine, donc la première lettre sera une majuscule pour marquer la
différence de nom. 
Le schéma de traduction d'un composant Scade foo en une implantation B est
le suivant:


\setlength{\columnseprule}{0.05cm}
\begin{multicols}{2}
\begin{alltt}
\textbf{node} foo 
  (in\(\sb{1}\): in\(\sb{1}\)\_type, ..., in\(\sb{p}\): in\(\sb{p}\)\_type) 
  \textbf{returns}
  (out\(\sb{1}\): out\(\sb{1}\)\_type, ..., out\(\sb{q}\): out\(\sb{q}\)\_type);
\textbf{var}
  v1 : v1\_type;
  ...
  vn : vn\_type;
  r1 : r1\_type;
  ...
  rn : rn\_type;
\textbf{let}
  assume in\(\sb{1}\) : pred\_in\(\sb{1}\);
  ...
  assume in\(\sb{p}\) : pred\_in\(\sb{p}\);

  \(liste d'equations\)

  guarantee out\(\sb{1}\) : pred\_out\(\sb{1}\);
  ...
  guarantee out\(\sb{q}\) : pred\_out\(\sb{q}\);
\textbf{tel;}
\end{alltt}

\columnbreak

\begin{alltt}
\textbf{IMPLEMENTATION} Foo_i
\textbf{REFINES} Foo

\textbf{IMPORTS} M\(\sb{imp}\)
\textbf{SEES} M\(\sb{see}\)

\textbf{CONCRETE\_VARIABLES} r1, ..., rn
\textbf{INVARIANT}
  r1 : r1\_type &
  ... &
  rn : rn\_type
\textbf{INITIALISATION}
  r1 := ;
  ... ;
  rn := ;

\textbf{OPERATION}

out\(\sb{1}\), ..., out\(\sb{q}\) \(\leftarrow\) foo(in\(\sb{1}\), ..., in\(\sb{p}\)) =
  
\textbf{VAR} v1, ..., vn \textbf{IN}
  
  \(sequence de substitutions\)

\textbf{END}
\end{alltt}
\end{multicols}

Les clauses invariant, initialisation et la séquence de substitutions
sont obtenues en appliquant la traduction des équations
sur la liste d'équations du composant Scade.

\section{Le traducteur}

Le traducteur\cite{Traducteur} a été écrit en OCaml, qui est un langage très efficace
pour développer des compilateurs, et donc des traducteurs.\\
Le parseur/lexeur a été écrit à partir de la grammaire de Scade,
définie dans le manuel Textual Scade\cite{ScadeRef}.
Les programmes parsés sont alors représentés sous forme d'arbre de
syntaxe abstraite, donné en annexe B. Cette représentation permet une
manipulation sur les différents éléments du programme, telle que la
liste d'équation sur laquelle est effectuée l'algorithme du tri
topologique. \\
On identifie également les différentes équations que l'on
répertorie en opération de base, registres, appel de noeud, et
alternative.

Cet arbre est ensuite transformé en un arbre donné en annexe C,
qui peut être imprimé dans deux fichiers de sortie, 
la machine abstraite et l'implantation qui correspondent au composant
donné en entrée. L'impression respecte la grammaire donnée dans le
Manuel de référence de B\cite{BRef}, et le couple de fichier peut être importé
dans un projet de l'Atelier B afin de vérifier le typage et la syntaxe
de chaque machine, et de passer les étapes d'obligation de preuve de
façon automatique.

