% -*- coding: utf-8; ispell-dictionary: "french"; -*-

%------------------------------------
% Chapter 3 - Schémas de traduction
%------------------------------------


Dans les deux parties précédentes, nous avons identifié les différents
éléments de Scade et de la méthode B dont nous avions besoin pour
établir la traduction. Cette partie définit les schémas de traduction
utilisés pour réaliser le traducteur. \\

\section{Specification}

La machine abstraite est engendrée à partir du contrat du composant. Ce sont
donc les conditions posées par les instructions \emph{assume} et
\emph{guarantee} qui nous intéressent. Le nom de l'opération sera le même que le
nom de la définition Scade. Le nom de la machine reprend également le nom de la
définition Scade, cependant le nom de l'opération doit être différent du nom de
la machine, donc la première lettre sera une majuscule pour marquer la
différence de nom. Ainsi, les défintions Scade doivent être écrites en
minuscules.

\subsection{Traduction de la déclaration du noeud}
La déclaration d'un noeud Scade comporte le nom du composant, ses
entrées/sorties, et le types de ses entrées/sorties. En B, on reprend ces
informations sur le nom du noeud et le nom des entrées sorties pour déclarer une
opération. Ainsi la déclaration Scade: 
\begin{alltt}
node mon\_noeud (in_1: type\_in_1, ..., in_n: type\_in_n) 
                returns (out_1: type\_out_1, ..., out_m: type\_out_m);
\end{alltt}
devient l'operation B:
\begin{alltt}
in_1, ..., in_n \(\leftarrow\) mon\_noeud(out_1, ..., out_m) =
\end{alltt}

Les informations de types sur les entrées et sorties sont reprises pour les
conditions.


\subsection{Traduction des conditions}

La machine abstraite de B forme une spécification de la machine implanté,
l'opération est ainsi ordinairement consitué d'une substitution précondition
PRE P THEN S END. P étant le prédicat correspondant aux conditions des
\emph{assumes} et aux informations de typage sur les entrées, tandis que S est
la substitution qui reprend les conditions sur les \emph{guarantees} et les informations de typage
sur les sorties. 

\paragraph{traduction des préconditions}
Les instructions \emph{assumes} sont des formules logiques, généralement des
restrictions sur des intervalles. Les opérateurs logiques utilisés sont les
mêmes pour Scade que pour le langage B, la traduction est donc directe. Les
conditions sur les différentes entrées sont combinées par un opérateur ET
logique (\&). La condition est précédée par le type de la variable, reprit
depuis la déclaration Scade. 
Dans le cas où une variable d'entrée ou de sortie n'est pas conditionnée, comme
c'est souvent le cas pour les variables booléennes, alors on indique seulement
le type de la variable.
Pour chaque variable le shéma de traduction est le suivant:
\begin{alltt}
assume in : formule_logique_sur_in
\end{alltt}
devient le prédicat B:
\begin{alltt}
in \(\in\) type\_in & formule\_logique\_sur\_in
\end{alltt}

\paragraph{traduction des postconditions}
Les instructions \emph{guarantee} sont également des formules
logiques. Cependant, on utilise des substitution \emph{devient element de} pour
les post-conditions. Les variables en sortie prennent une valeur comprise dans
un certain ensemble donné dans la formule logique. Les substitutions sont
regroupée dans une substitution parallèle, elles sont séparées par un ||. Le
schéma de traduction est le suivant:
\begin{alltt}
guarantee out : formule_logique_sur_out
\end{alltt}
devient la substitution B:
\begin{alltt}
out \(\in\): \{ iii | iii \(\in\) type_out & formule_logique_sur_out\}
\end{alltt}
Cette substitution se lit \emph{out} devient l'élément \emph{iii} de l'ensemble
de \emph{type\_out} respectant \emph{formule\_logique\_sur\_out}.

\paragraph{Traduction des types}
La traduction des types de base est directe:
\begin{itemize}
\item int est traduit par INT
\item real est traduit par REAL
\item bool est traduit par BOOL
\end{itemize}

\subsection{Le cas des tableaux}
La traduction des conditions pour les tableaux est moins directe, car il n'y a
pas de type primitifs pour les tableaux en B. On utilise des fonctions à la
place. 

\paragraph{Traduction des types}
Les tableaux peuvent être multi-dimensionnels, mais ne peuvent contenir qu'un
seul type de donnée. On peut voir les tableaux comme des fonctions prennant
comme argument l'indice de la donnée stockée, et retournant la valeur de cette
donnée. Les tableaux sont indexés par des entiers, selectionnés dans les
intervalles allant de 1 à la taille du tableau.
Par exemple, pour une matrice \emph{Mat} de n lignes et m colonnes, les valeurs
des données sont accessibles ainsi: $Mat(p, q)$, avec $1 \leq p \leq n$ et $1 \leq q
\leq m$.
Ainsi, le schéma correspondant à la traduction de la déclaration d'un tableau
est:
\begin{alltt}
nom\_tableau : type\_tableau \^ dim_1 \^ ... \^ dim_n
\end{alltt}
devient la substitution B:
\begin{alltt}
nom\_tableau : (1..dim_1, ..., 1..dim_n) \(\rightarrow\) type\_tableau 
\end{alltt}
Dans la traduction B, la notation $1..dim_1$ correspond à un
intervalle allant de 1 à la valeur de dim$_1$
\paragraph{Traduction des formules logiques}
Les conditions sur les tableaux en B ont été évoquées dans la section sur les
quantificateurs en B. Les conditions portent sur l'ensemble des données
contenues dans le tableau. La condition est alors de la forme: pour toute valeur
iii correspondant à un index du tableau, la donnée référencée par cet index
respecte la condition donnée. Ainsi, une formule logique f\_l portant sur un
tableau T de n dimensions correspond à la formule B: 
\begin{alltt}
\(\forall \)iii. (iii : (1..dim_1, ..., 1..dim_n) \(\rightarrow\) f\_l)
\end{alltt}

\subsection{schéma général}

Le shéma de traduction d'un composant Scade foo en une machine abstraite B est
le suivant:

\setlength{\columnseprule}{0.05cm}
\begin{multicols}{2}
\begin{alltt}
\textbf{node} foo 
  (in\(\sb{1}\): in\(\sb{1}\)\_type, ..., in\(\sb{p}\): in\(\sb{p}\)\_type) 
  \textbf{returns}
  (out\(\sb{1}\): out\(\sb{1}\)\_type, ..., out\(\sb{q}\): out\(\sb{q}\)\_type);
\textbf{var}
  v1 : v1\_type;
  ...
  vn : vn\_type;
  r1 : r1\_type;
  ...
  rn : rn\_type;
\textbf{let}
  assume in\(\sb{1}\) : pred\_in\(\sb{1}\);
  ...
  assume in\(\sb{p}\) : pred\_in\(\sb{p}\);

  \( liste d'equations \)

  guarantee out\(\sb{1}\) : pred\_out\(\sb{1}\);
  ...
  guarantee out\(\sb{q}\) : pred\_out\(\sb{q}\);
\textbf{tel;}
\end{alltt}
\columnbreak

\begin{alltt}
\textbf{MACHINE} Foo

\textbf{OPERATION}

out\(\sb{1}\), ..., out\(\sb{q}\) \(\leftarrow\) foo(in\(\sb{1}\), ..., in\(\sb{p}\)) =
  \textbf{PRE}
    in\(\sb{1}\) \(\in\) in\(\sb{1}\)\_type & pred\_in\(\sb{1}\) &
    ... &
    in\(\sb{p}\) \(\in\) in\(\sb{p}\)\_type & pred\_in\(\sb{p}\) &
  \textbf{THEN}
    out\(\sb{1}\) \(\in\): \{ iii | iii \(\in\) out\(\sb{1}\)\_type & pred\_out\(\sb{1}\)\}
    ...
    out\(\sb{q}\) \(\in\): \{ iii | iii \(\in\) out\(\sb{q}\)\_type & pred\_out\(\sb{q}\)\}
  \textbf{END}
\textbf{END}
\end{alltt}
\end{multicols}

\emph{note: les formules booléennes sont notées pred\_nom où nom
  correspond au nom de la variable concernée par cette formule, qui à
  la même syntaxe en Scade et en B}

\section{Implémentation}


\subsection{Traduction des équations}

Les équations sont traduites différemment selon le "type" d'expression qu'elles
contiennent.  
Concernant la partie droite, il y a 4 types d'expressions de Scade à traduire en B:
\begin{itemize}
\item Les expressions à manipulant les variables, constantes et opérateurs de
  base (arithmétiques, relationnels, booléens,...).
\item Les appels de noeuds, sous réserve que le noeud appelé a déjà été
  traduit. 
\item L'alternative.
\item Le registre.
\end{itemize}

\paragraph{Opérateurs de base}
Les opérateurs de base sont traduits par une substitution \emph{devient égal}, on
effectue une simple affectation. Les opérateurs de base de Scade sont identiques
à ceux du langage B. Le membre gauche de l'équation correspond à une unique
variable, les opérations étant atomiques dans Scade. \\

$a = op(b_1,...,b_n)$ $\xrightarrow{traduction ~ equations}$ $a:=op(b_1,...,b_n)$. 

\paragraph{Appel de noeud}
Un appel de noeud est traduit par une substitution \emph{appel d'opération}.le
membre gauche de l'équation contient autant de variables qu'il y a de sorties
pour le noeud appelé. Le noeud appelé doit avoir été traduit auparavant, et la
machine B correspondante doit êtreprésente dans la clause \emph{IMPORT}.\\

$(a_1, ... a_n) = n(b_1, ..., b_m)$ $\xrightarrow{traduction ~ equations}$ $(a_1, ... a_n) \leftarrow n(b_1,
..., b_n)$

\paragraph{Alternative}
On traduit l'alternative par la substitution \emph{conditionnelle}. On utilise
également la substitution \emph{devient égal} pour chaque branche de l'alternative.\\

$ a = if~ cond~ then~ b1~ else~ b2$ $\xrightarrow{traduction ~ equations}$ $IF ~cond~ THEN ~a:=b1~ ELSE
~a:=b2$

\paragraph{Registre}
Le registre est également traduit en substitution \emph{devient égal}, cependant
les substitutions correspondantes doivent être placées après les autres. Ces
équations correspondent à la mise à jour de l'état d'une variable, la mise à
jour est donc faite à la fin de l'opération. La valeur initiale du registre doit
être indiquée dans la clause \emph{INITIALISATION} de la machine et la variable d'état
correspondant au registre doit être déclarée dans \emph{CONCRETE\_VARIABLE}. De
plus il faut indiquer dans la clause \emph{INVARIANT} les contraintes de typage
de la variable d'état. \\

$a = ini \rightarrow (pre ~b)$ $\xrightarrow{traduction ~ equations}$ $a := b$ 

\paragraph{Tri topologique}
Dans Scade, l'ordre des équations n'a pas d'importance, mais en B elles doivent
s'exécuter en séquence. Les équations correspondants aux registres sont
automatiquements placées à la fin, car elles mettent à jour l'état de la machine
après son exécution. Il faut donc effectuer un tri topologique des 3 autres
types d'équations.\\
On utilise alors une fonction de tri prenant en entrées :
\begin{itemize}
\item la liste des équations du programme (sans les équations de registre)
\item la liste des variables d'entrée du programme.
\end{itemize}
La fonction retourne une liste d'équations triées selon l'ordre
topologique.

\begin{alltt}
Fonction Tri (eqs: liste d'equations, vars\_in: liste de variables)

eq\_non\_triees : liste d'equations
eq\_admis : liste d'equations
v\_admis : liste de variables 
eq : equation

BEGIN
 eq\_non\_triees <- eqs;
 v\_admis <- vars\_in;
 TANT QUE (eq\_non\_triees \(\neq \emptyset \)) 
    eq <- tete(eq\_non\_triees);
    SI vars\_droite(eq) \(\subset\) v\_admis ALORS
       ajout\_fin(eq\_admis, eq);
       ajout\_fin(v\_admis, vars\_gauche(eq))
    SINON
       ajout\_fin(eq\_non\_triees, eq)
    FIN SI
 FIN TANT QUE
 RETOURNE eq\_admis;
END

\end{alltt}

On utilise 4 procédures externe nécessaire à cet algorithme:
\begin{itemize}
\item tete(l) : retourne le premier élément de la liste l et supprime l'élément
  en question de l
\item ajout\_fin(l,e) : ajoute e à la fin de la liste l
\item vars\_droite(e) : liste des variables contenues dans la partie droite de
  l'équation e
\item vars\_gauche(e) : liste des variables contenues dans la partie gauche de
  l'équation e
\end{itemize}
la préocédure tete retourne le premier élément de la liste donnée en argument,
et le supprime. La procédure 
Pour commencer, les variables d'entrées sont considérées comme admises. Les
premières équations sont celles dont la partie droite ne dépend que des
variables admises. La partie gauche des premières équations est ajoutée à la
liste des variables admises, et on ajoute les équations dont la partie droite
dépend du nouveau set de variables admises. La fonction retourne la liste d'
équations triée.

\subsection{Retour sur la traduction des registres}
Dans Scade, les équations correspondant aux registres sont initialisées à une
certaine valeur, puis ils prennent la valeur d'une autre variable pour les
instants suivants. Avec B, les registres sont des variables
d'état, qui auront lors de l'initialisation du programme la valeur définie pour
le premier instant avec Scade.
Cette initialisation de registre doit se faire dans la clause INITIALISATION, et
le nom du registre doit auparavant être déclaré dans la clause CONCRETE\_VARIABLES. L'information de
type du registre doit alors être déclarée comme prédicat dans la clause
INVARIANT. De plus, si le registre porte sur une variable d'entrée ou de sortie,
on peut alors récupérer la condition (si elle existe) sur l'entrée ou la sortie
en question pour compléter le prédicat de la clause INVARIANT. 

Ainsi, soit un registre reg de type t, ayant l'équation suivante :\\
$reg = ini \rightarrow (pre ~a)$ \\
avec a une variable d'entrée ou de sortie du composant, possédant une
précondition ou postcondition P, et ini une valeur d'initialisation de
reg. Il faudra alors écrire dans l'implantation correspondante: 

\begin{alltt}
\textbf{IMPLEMENTATION} ...
...

\textbf{CONCRETE\_VARIABLES} ..., reg
\textbf{INVARIANT}
  ...& reg : t & P
\textbf{INITIALISATION}
  ... ; rn := ini;

\textbf{OPERATION}
... =
\textbf{VAR} ... \textbf{IN}
  ...;
  reg := a
\textbf{END}
\end{alltt}

\subsection{Gestion des clauses SEES et IMPORTS}
Pour inclure des opérations ou des constantes définies dans des machines
externes, il faut les ajouter respectivement dans les clauses IMPORTS et SEES de
la machine courante. Cependant, il n'y a pas de processus automatique pour
ajouter les machines nécessaires dans ces clauses. Il faut donc les ajouter
manuellement une fois la traduction est réalisée.


\subsection{schéma général}

Le shéma de traduction d'un composant Scade foo en une implémentation B est
le suivant:


\setlength{\columnseprule}{0.05cm}
\begin{multicols}{2}
\begin{alltt}
\textbf{node} foo 
  (in\(\sb{1}\): in\(\sb{1}\)\_type, ..., in\(\sb{p}\): in\(\sb{p}\)\_type) 
  \textbf{returns}
  (out\(\sb{1}\): out\(\sb{1}\)\_type, ..., out\(\sb{q}\): out\(\sb{q}\)\_type);
\textbf{var}
  v1 : v1\_type;
  ...
  vn : vn\_type;
  r1 : r1\_type;
  ...
  rn : rn\_type;
\textbf{let}
  assume in\(\sb{1}\) : pred\_in\(\sb{1}\);
  ...
  assume in\(\sb{p}\) : pred\_in\(\sb{p}\);

  \(liste d'equations\)

  guarantee out\(\sb{1}\) : pred\_out\(\sb{1}\);
  ...
  guarantee out\(\sb{q}\) : pred\_out\(\sb{q}\);
\textbf{tel;}
\end{alltt}

\columnbreak

\begin{alltt}
\textbf{IMPLEMENTATION} Foo_i
\textbf{REFINES} Foo

\textbf{IMPORTS} M\(\sb{imp}\)
\textbf{SEES} M\(\sb{see}\)

\textbf{CONCRETE\_VARIABLES} r1, ..., rn
\textbf{INVARIANT}
  r1 : r1\_type &
  ... &
  rn : rn\_type
\textbf{INITIALISATION}
  r1 := ;
  ... ;
  rn := ;

\textbf{OPERATION}

out\(\sb{1}\), ..., out\(\sb{q}\) \(\leftarrow\) foo(in\(\sb{1}\), ..., in\(\sb{p}\)) =
  
\textbf{VAR} v1, ..., vn \textbf{IN}
  
  \(sequence de substitutions\)

\textbf{END}
\end{alltt}
\end{multicols}

Les clauses invariant, initialisation et la séquence de substitutions
sont obtenues en appliquant la traduction des équations
sur la liste d'équations du composant Scade.

\section{Le traducteur}

Le traducteur a été écrit en OCaml, qui est un langage très efficace
pour développer des compilateurs, et donc des traducteurs.\\
Le parseur/lexeur a été écrit à partir de la grammaire de Scade,
définie dans le manuel Textual Scade.

Les programmes parsés sont alors représentés sous forme d'arbre de
syntaxe abstraite, donné en annexe A. Cette représentation permet une
manipulation sur les différents éléments du programme, telle que la
liste d'équation sur laquelle est effectuée l'algorithme du tri
topologique. \\
On identifie également les différentes équations que l'on
répertorie en opération de base, registres, appel de noeud, et
alternative.

Cet arbre est ensuite transformé en un arbre donné en annexe B,
qui peut être imprimé dans deux fichiers de sortie, correspondant à
la machine abstraite et à l'implantation correspondant au composant
donné en entrée. L'impression respecte la grammaire donnée dans le
Manuel de référence de B, et le couple de fichier peut être importé
dans un projet de l'Atelier B afin de vérifier le typage et la syntaxe
de chaque machine, et de passer les étapes d'obligation de preuve de
façon automatique.
