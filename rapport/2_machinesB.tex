% -*- coding: utf-8; ispell-dictionary: "french"; -*-

%------------------------
% Chapter 2 - Machines B
%------------------------

Concernant le langage B, langage de sortie du traducteur, nous
n'aurons besoin d'utiliser que les éléments nécessaires pour exprimer
les éléments de Scade en B, et pour certifier formellement le
composant ainsi traduit.\\
La méthode B s'appuie sur un raisonnement mathématique rigoureux, basé
sur des étapes de raffinements. Nous n'aurons besoin que d'une étape de
raffinement pour notre traducteur. Il faudra ainsi produire deux
machines en sortie du traducteur:
\begin{itemize}
\item une signature : elle correspond à la machine abstraite
  qui reprend les éléments de spécification du composant traduit.
\item une implantation : elle raffine la machine abstraite et
  contient les substitutions correspondant à l'opération définie dans
  le composant.
\end{itemize}
La méthode B est utilisée avec l'environnement de développement
AtelierB, développé par Clearsy. Nous utiliserons cet environnement
pour vérifier que le code traduit est correctement traduit en B à
l'aide d'un analyseur syntaxique intégré ainsi qu'un type checkeur. On
utilise ensuite l'environnement pour générer les obligations de
preuves liées au couple de machines.



% SECTION 1 : Machines

\section{Machine B}

\subsection{Structure d'une machine}

Une machine B est divisée en \emph{clauses}, que l'on peut assimiler à
des services permettant l'initialisation puis l'évolution des données
manipulées. Une clause ne peut-être utilisée plus d'une fois dans une
machine, mais l'ordre n'est pas imposé. Il en existe une vingtaine,
mais nous n'en utiliserons que sept, que nous détaillerons dans la
partie suivante.\\ 
Ces données sont exprimées dans le même type qui est utilisé avec
Scade, c'est à dire soit des entiers, soit des réels, soit des
booléens, soit des tableaux de ces types, qui sont des types primitifs
du langage B. \\ 
La machine abstraite reprenant la spécification du composant contient
des prédicats portant sur ces données, et la transformation
de ces prédicats se fait grâce à un mécanisme de substitutions. Les
différentes substitutions requises pour ce projet seront détaillées
dans la partie correspondante. \\
Une machine est précédée d'un en-tête qui diffère selon la machine
abstraite et l'implantation:
\begin{itemize}
\item pour la signature, l'en-tête sera composé du mot MACHINE suivi
  du nom du composant.
\item pour l'implantation, ce sera IMPLEMENTATION suivi du nom du
  composant auquel on ajoute le suffixe "\_i".
\end{itemize}
Voir annexe A pour un exemple de couple de machines abstraite/implantation.



\subsection{Clauses}
Les différentes clauses requises pour assurer la traduction sont
décrites dans cette partie. La machine abstraite ne requière pas les
clauses IMPORTS, CONCRETE\_VARIABLES, INVARIANT et INITIALISATION car
elle ne manipule que la spécification. En revanche, l'implémentation ne
manipule que des données et substitutions ayant un équivalent
informatique, similaire à un langage impératif, et on aura besoin de
ces clauses pour exprimer l'opération définie dans le composant Scade.

\paragraph{Refines}
La clause refines est présente dans la machine implémentation afin
d'indiquer la machine qui est raffinée. Nous ne faisons qu'une étape
de raffinement, donc la machine raffinée sera toujours la machine
abstraite. 

\paragraph{Imports}
Ici, nous indiquons quelles machines B seront nécessaires pour
manipuler les données. Pour la programmation par composant, nous avons
besoin de faire appel à d'autres composants, et cette clause permet
d'importer une instance de ces composants. Lors d'un appel d'opération d'un machine
importée, l'opération est instanciée.

\paragraph{Sees}
Nous avons besoin de faire aussi appel à des machines contenant
des définitions de constantes. Nous mettrons la liste des machines nécessaires
dans cette clause. Ce sont des machines vues, car il n'y a aucune instanciation
d'opération, on a seulement besoin de voir les constantes et leurs valeurs.

\paragraph{Concrete\_Variables}
Cette clause indique quelles sont les variables d'état de la
machine. C'est dans cette clause que nous déclarons les registres
définis dans le composant Scade. Les autres variables locales sont définies dans
une substituion VAR.

\paragraph{Invariant}
Nous pouvons alors établir des invariants sur les registres déclarés dans la
clause précédente dans cette clause. Les invariants seront des restrictions sur les
intervalles sur lesquels les registres seront manipulés, et ils seront écrits
sous forme de prédicats.

\paragraph{Initialisation}
L'initialisation permet d'indiquer la valeur donnée aux registres lors
de l'initialisation du composant, ce sont des substitutions. L'initialisation doit être en accord
avec l'invariant.

\paragraph{Opérations}
La clause principale d'une machine B est la clause Operations. On y
défini la spécification du composant dans la machine abstraite, et
cette spécification est concrétisée dans l'implantation où on écrira
les expressions du composant sous forme de substitutions et de prédicats. Bien
qu'on puisse définir autant d'opération qu'on le souhaite dans cette clause,
nous ne définirons qu'une seule opération, celle correspondant au composant Scade.


\subsection{Prédicats}

Un prédicat est une formule mathématique qui peut être prouvée ou
réfutée. Elle peut être présente pour exprimer des propriétés sur une
donnée, comme dans la clause \emph{Invariant}, ou dans la substitution
Precondition. Elle peut-être aussi utilisée pour exprimer une
condition, comme dans la substitution Condition.

\paragraph{}
Les prédicats de base sont exprimables à l'aide des opérateurs de
comparaison habituels: $<,~>,~\leq,$ et $\geq$. Les expressions doivent
être de type entier ou réel.

\paragraph{}
Pour exprimer un prédicat plus complexe à partir de prédicats basique,
on utilise des opérateurs de proposition : conjonction $\vee$,
disjonction $\wedge$, négation $\neg$, parenthèses $()$, implication
$\Rightarrow$ et équivalence $\Leftrightarrow$.\\
Par exemple, soit $P$ et $Q$ des prédicats: $P\wedge\neg(Q)$

\paragraph{}
On utilisera aussi le quantificateur $\forall$, notamment lorsqu'on
définira des tableaux, pour établir une condition pour tous les
éléments du tableau. Et on aura besoin de l'opérateur d'appartenance à
un ensemble $\in$.\\
Par exemple, soit $tab$ un tableau : $\forall iii . (iii \in (1..5)
\Rightarrow tab(iii) < 5)$\\
Cet exemple indique que tout élément du tableau ayant un indice compris
entre 1 et 5 doit être strictement inférieur à 5. 

%% NOTE: ON PEUT SE PASSER DU APPARTIENT AVEC \\
%% !iii . (iii : INT $\wedge$ iii > 0 $\wedge$ 6 > iii => tab(iii) < 5) \\
%% A REGARDER DANS IMPLEM


% SECTION 2 : Expressions

\section{Expressions}

\paragraph{}
Les expressions permettent de désigner les données utilisées. Les
expressions de base désignent une variable ou une valeur primitive.
On retrouve toutes les expressions arithmétiques classiques, addition,
soustraction, multiplication, division et modulo.

\paragraph{Des fonctions}

Nous utiliserons également les fonctions, pour appeler des opérations
définies dans d'autres composants, mais aussi pour modéliser les
tableaux en B. Il n'y a pas de type primitif tableau en B, il faut les
modéliser à l'aide de fonctions.

\paragraph{Les tableaux en B}
Un tableau est une fonction dont l'ensemble de départ est le produit
cartésien de n ensembles (où n correspond au nombre de dimensions du
tableau), et dont l'ensemble d'arrivée est un ensemble concret.\\
Par exemple, soit $tab$ un tableau, \\
$tab \in (0..4)*(0..5) \rightarrow INT$ \\
est une matrice de 5 lignes et 6 colonnes contenant des entiers.


% SECTION 3 : Substitutions

\section{Substitutions}
Les substitutions permettent de transformer les prédicats, il en existe 18 mais
nous ne nous intéresseront qu'à la moitié d'entre elles. Soit une substitution S et un
prédicat P, \emph{[S]P} se lit "la substitution S établit le prédicat P".
Les substitutions ne sont présentes que dans les clauses Initialisation et
Operations. Dans la partie suivante, on détaillera comment passer des équations
de Scade à ces substitutions.

\paragraph{Substitution Sequence}
Une séquence permet d'appliquer en séquence deux substitutions à un
prédicat. Les deux substitutions sont séparées par un \textbf{;} .

\paragraph{Substitution Parallèle}
A la différence de la substitution séquence, la substitution parallèle permet
d'effectuer deux substitutions de façon simultanée et indépendamment l'une de
l'autre. Les deux substitutions sont séparées par \textbf{||} . Cette substitution n'est
disponible que pour la machine abstraite.

\paragraph{Substitution Devient égal}
Cette substitution réalise l'affectation, elle remplace une variable
par une expression. Elle se note : Soit e une expression, x une
variable et P un prédicat,

[ x:=e ] P \\
Le prédicat obtenu a alors toute les occurrences libre de x dans P par e.

\paragraph{Substitution Devient Element De}
Les conditions sur les entrées et sorties du programmes sont souvent
des restrictions sur des ensembles de valeurs. Cette substitution permet
d'attribuer à une variable, une valeur tirée dans un ensemble. Elle se note:
Soit E un ensemble et X une variable, 

[X:$\in$ E] \\
Cette substitution n'est pas une substitution d'implantation.

\paragraph{Substitution Condition}
C'est cette substitution que l'on utilise pour exprimer le choix entre deux
substitutions. Elle se note : Soit P et R des prédicats, et S et T des
substitutions,

[IF P THEN S ELSE T]R \\
Si le prédicat P est évalué à vrai, alors c'est la substitution S que l'on
applique au prédicat R. Si P est faux, alors c'est la substitution T qui
s'applique à R.

\paragraph{Substitution Variable Locale}
Cette substitution n'est pas utilisée dans la machine abstraite. Elle permet
d'introduire une liste de variables locales.
Elle se note : Soit S une séquence de substitutions et X une liste de variables,

[VAR X IN S END]\\
La liste de variable sera accessible dans les substitutions S contenues dans le
bloc IN ... END, correpondant à une substitution bloc.

\paragraph{Substitution Precondition}
Cette substitution n'est utilisée que dans la machine abstraite. Elle fixe les
préconditions sous lesquelles une substitution sera valide. Elle se note : Soit P
un prédicat et S une substitution,

[PRE P THEN S END]\\
L'application de cette substitution correspond à la preuve de la
précondition P et à l'application de la substitution S. Si la
précondition P est fausse, le résultat de la substitution n'est alors
plus garantit.

\paragraph{Substitution Appel operation}
cette substitution se note : Soit R un identificateur correspondant à la sortie
de l'opération op appliquée aux expressions E, 

[R$\leftarrow$ op(E)]P\\
La  substitution appel d’opération permet d’appliquer la substitution
d’une opération (non locale ou locale), en remplaçant les paramètres
formels par des paramètres effectifs. 

\paragraph{}
On retrouve ainsi les constructions d'un langage de programmation
impératif, avec des affectations, appels d'opération, alternative, et la
définition de variables locales. De plus, les substitutions sont
réordonnées via un tri topologique par rapport aux équations du composant
Scade, dont l'ordre n'avait pas d'importance. Cette distinction entre
les deux langages, synchrone contre impératif, sera développée dans la
section concernant la preuve de correction du traducteur.


% SECTION 4 : Raffinements

\section{Raffinements}

\subsection{Principes du raffinement}

Le raffinement d'une machine est une reformulation en une
expression plus concrète et enrichie. La relation de raffinement est transitive:
les valeurs calculées par l'implantation sont conformes à celles attendues par
la machine abstraite. 

L'implantation correspond à un code exécutable après une compilation vers du
code C ou Ada. Donc vers un programme équivalent à celui écrit avec
Scade, qui est également compilé vers du C en fin de chaîne. Cependant
nous ne nous intéresserons pas au programme produit par l'atelierB,
car le compilateur de Scade produisant le C (KCG 6) est qualifié pour produire
du code certifié pour la norme DO178b.

Ainsi, le raffinement permet de concrétiser un programme jusqu'à obtenir un code
exécutable, mais il permet surtout de générer un certain nombre de preuves à
démontrer pour prouver que la reformulation de la spécification est valide.
La génération des hypothèses à démontrer est automatique dans l'Atelier B, grâce à la
transformation des prédicats par les substitutions. 

La machine abstraite reprendra uniquement les éléments du contrat du composant,
c'est à dire les conditions indiquées sur les entrées et sorties du noeud
Scade. Ce sont ces conditions qui devront être vérifiée par les différents
raffinements de la machine abstraite. Nous n'utiliserons qu'une étape de
raffinement: l'implantation. Il faut donc prouver que cette machine raffinée
conserve les propriétés invariantes de la machine abstraite.

La forme générale d'une machine abstraite et de son raffinement est le suivant:



\setlength{\columnseprule}{0.05cm}
\begin{multicols}{2}
\begin{alltt}
\textbf{MACHINE} M

\textbf{OPERATION}

outs \(\leftarrow\) op(ins) =
  \textbf{PRE}
    P
  \textbf{THEN}
    S
  \textbf{END}

\textbf{END}
\end{alltt}
\columnbreak
\begin{alltt}
\textbf{IMPLEMENTATION} M\_i
\textbf{REFINES} M

\textbf{IMPORTS} M\(\sb{imp}\)
\textbf{SEES} M\(\sb{see}\)

\textbf{CONCRETE\_VARIABLES} regs
\textbf{INVARIANT}
  Inv
\textbf{INITIALISATION}
  Ini

\textbf{OPERATIONS}
  
outs \(\leftarrow\) op(ins) =
  S'

\textbf{END}
\end{alltt}
\end{multicols}



\subsection{Obligations de preuves}

Pour chaque machine, depuis la spécification à l'implémentation, il faut
passer une étape de type checking et d'obligation de preuve. L'étape de type
checking vérifie la cohérence des types des données manipulées ainsi que la
syntaxe du programme. Une fois cette étape validée, on peut générer les
obligations de preuves. Le principe des obligations de preuves consiste à
prouver une formule à partir d'une liste d'hypothèses:\\
Hypothèses (liste de prédicats)\\
$\Rightarrow$\\
But (doit être prouvé sous ces hypothèses)\\
On ne montrera pas la construction des différentes obligations de
preuves, ces dernières ont été définies dans le B-Book. 

\noindent
Pour l'implantation, les obligations seront générées pour la clause opération,
mais aussi pour la clause initialisation. 

\paragraph{Initialisation de l'implantation} Pour l'initialisation, la preuve
dépend également des machines présentes dans les clauses IMPORTS et
SEES. L'obligation de preuve générée est la suivante:\\

\bcode{Inv$_{imp}$ $\wedge$ Inv$_{see}$ $\Rightarrow$ [Ini$_{imp}$; Ini] Inv} \\

Avec Inv$_{imp}$ et  Inv$_{see}$ les invariants des machines importées et vues,
et Ini$_{imp}$ les initialisations des machines importées. \\
...EXPLICATION NECESSAIRE

\paragraph{Opération de l'implantation}
L'opération de l'implantation dépend également des machines importées et vues, mais
aussi et surtout de la machine qu'elle raffine. L'obligation générée est la
suivante:\\

\bcode{Inv$_{imp}$ $\wedge$ Inv$_{see}$ $\wedge$ Inv $\wedge$ P $\Rightarrow$ [S']$ \neg
$[S]$ \neg $(Inv)}\\

...EXPLICATION NECESSAIRE



