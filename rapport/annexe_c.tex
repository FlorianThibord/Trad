\noindent
Le fichier \texttt{ast\_repr\_b.ml} contient la définition de l'arbre de
syntaxe abstraite d'un composant avant d'être imprimé dans deux fichiers: 
la machine abstraite et à l'implantation.
\begin{small}
\begin{verbatim} 

(* Expressions B *)
type b_expression =
  BE_Ident of ident
| BE_Value of value
| BE_Bop of bop * b_expression * b_expression
| BE_Unop of unop * b_expression
| BE_Sharp of b_expression list
| BE_Array of array_expr

and array_expr =
  BA_Def of b_expression list
| BA_Caret of b_expression * b_expression
| BA_Concat of b_expression * b_expression
| BA_Slice of ident * (b_expression * b_expression) list
| BA_Index of ident * b_expression list
| BA_Reverse of b_expression

type left_part =
  BLP_Ident of ident 
| BLP_Tuple of ident list

(* Les equations sont désormais séparées en 4 familles  qui seront imprimées
selon les schémas de traductions définis *)

type alternative =
  { alt_lp: left_part;
    alt_cond: b_expression;
    alt_then: b_expression;
    alt_else: b_expression;
  }

type fonction =
  { fun_lp: left_part;
    fun_id: ident;
    fun_params: b_expression list;
  }

type operation =
  { op_lp: left_part;
    op_expr: b_expression;
  }

type registre =
  { reg_lpid: ident;
    reg_val: b_expression;
  }

type equation =
  Alternative of alternative
| Fonction of fonction
| Operation of operation

(* Initialisation des registre *)
type initialisation =
  ident * b_expression

(* Conditions sur les parmètres d'entrées, les sorties et les registres *)
type condition =
  Base_no_expr of ident * base_type
| Fun_no_expr of ident * base_type * b_expression list
| Base_expr of ident * base_type * b_expression
| Fun_expr of ident * base_type * b_expression list * b_expression

(* Déclaration d'une opération *)
type op_decl =
  { id: ident;
    param_in: ident list;
    param_out: ident list;
  }

(* Opération de l'implantation *)
type operations =
  { op_decl: op_decl; 
    vars: ident list;
    op_1: equation list;
    op_2: registre list;
  }

(* Implantation *)
type b_impl =
  { name: ident;
    refines: ident;
    sees: ident list;
    imports: ident list;
    concrete_variables: ident list;
    invariant: condition list;
    initialisation: initialisation list;
    operations: operations;
  }

(* Opération de la machine abstraite *)
type abst_operation =
  { abstop_decl: op_decl;
    abstop_pre: condition list;
    abstop_post: condition list;
  }

(* Machine abstraite *)
type b_abst =
  { machine: ident;
    abst_sees: ident list;
    abst_operation: abst_operation;
  }

(* Création Environnement *)
module Env = Map.Make(
  struct
    type t = ident
    let compare = compare
  end
)
type env = (ident * Ast_repr_norm.n_expression option) Env.t

type prog =
  { env: env;
    machine_abstraite: b_abst;
    implementation: b_impl;
  }

\end{verbatim}
\end{small}
