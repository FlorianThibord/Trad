
node controle(TD, TI, CP: bool)
returns(veilleuse, code, phare: bool);
var etat_0 : bool;
let
  assert not ( (TD and TI) or (TI and CP) or (TD and CP) );

  etat_0= true -> if pre veilleuse and TI then true
                  else if pre etat_0 and TD then false
                       else pre etat_0;
  
  -- On suppose que la manette CP ne permet que de commuter entre code et phare, 
  -- c'est à dire que même si on appuie sur CP alors qu'on est en veilleuse,  dans tout les cas 
  -- TD allumera les codes
  veilleuse = false -> if (pre etat_0 and TD) or ( (pre phare or pre code) and TI) then true
                       else if pre veilleuse and (TI or TD) then false
                            else pre veilleuse;
  
  code = false -> if (pre veilleuse and TD) or (pre phare and CP) then true
                  else if pre code and (TI or CP) then false
                       else pre code;

  phare = false -> if pre code and CP then true
                   else if pre phare and (CP or TI) then false
                        else pre phare;
  
  
tel

node controle_etendu(TD, TI, CP, AB, LP : bool)
returns(veilleuse, code, phare, anti_brouillard, longue_portee: bool);
var on_ab, on_lp: bool;
let
  (veilleuse, code, phare) = controle(TD, TI, CP);
  on_ab = AB -> if AB then not pre on_ab
                else pre on_ab;
  on_lp = LP -> if LP then not pre on_lp
                else pre on_lp;
            
  anti_brouillard = code and on_ab;
  longue_portee = phare and on_lp;
tel

node check_controle(TD, TI, CP, AB, LP : bool)
returns (ok: bool)
var veilleuse, code, phare, anti_b, longue_p: bool;
let
  (veilleuse, code, phare, anti_b, longue_p) = controle_etendu(TD, TI, CP, AB, LP);
  ok = not ( (veilleuse and code) or (code and phare) or (phare and veilleuse) ); 
tel

